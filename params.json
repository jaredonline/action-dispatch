{"name":"D Lang Action Pack","tagline":"Rails-like routing for your Vibe.D project!","body":"D Lang Action Pack\r\n===========\r\n\r\nA router for use with [Vibe-D](http://vibed.org/) that mimics the way routers and controllers work in [Rails](http://rubyonrails.org/).\r\n\r\n## Installation\r\n\r\nAdd the following to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n    \"action-pack\": \"~master\"\r\n}\r\n```\r\n\r\n## Usage\r\n\r\nHere's a very quick sample run through of how you can use the `ActionPack` routing.\r\n\r\n### App.d and the router\r\n\r\nFirst you have to setup your `app.d` file with your router and your list of routes:\r\n\r\n```d\r\n// app.d\r\n\r\nimport vibe.d;\r\nimport action_dispatch.all;\r\n\r\nshared static this()\r\n{\r\n\tauto router = new ActionRouter;\r\n\trouter.get(\"/\", \"BooksController\", \"index\");\r\n\t\r\n\trouter.resources(\"authors\", delegate void (ActionNamespace authors) {\r\n\t  authors.resources(\"books\");\r\n\t});\r\n\r\n\tauto settings = new HTTPServerSettings;\r\n\tsettings.port = 8080;\r\n\r\n\tlistenHTTP(settings, router);\r\n}\r\n```\r\n\r\nIn the above example we map the default route of `/` to be handled by the `BooksController` action `index`.\r\n\r\nThen we define a resource, `authors` and a sub resource for `authors`: `books`. This generates a routing table:\r\n\r\n\r\n|Method|Route|Controller|Action|\r\n|:------|:-----------|:-----|:----|\r\n|GET|/|BooksController|#ndex|\r\n|GET|/authors/:author_id/books|BooksController|#index|\r\n|GET|/authors/:author_id/books/new|BooksController|#init|\r\n|POST|/authors/:author_id/books|BooksController|#create|\r\n|GET|/authors/:author_id/books/:id|BooksController|#show|\r\n|GET|/authors/:author_id/books/:id/edit|BooksController|#edit|\r\n|PUT|/authors/:author_id/books/:id|BooksController|#update|\r\n|PATCH|/authors/:author_id/books/:id|BooksController|#update|\r\n|DELETE|/authors/:author_id/books/:id|BooksController|#destroy|\r\n|GET|/authors|AuthorsController|#index|\r\n|GET|/authors/new|AuthorsController|#init|\r\n|POST|/authors|AuthorsController|#create|\r\n|GET|/authors/:id|AuthorsController|#show|\r\n|GET|/authors/:id/edit|AuthorsController|#edit|\r\n|PUT|/authors/:id|AuthorsController|#update|\r\n|PATCH|/authors/:id|AuthorsController|#update|\r\n|DELETE|/authors/:id|AuthorsController|#destroy|\r\n\r\n\r\n\r\nFrom just a few lines of code we get 17 routes! All with automatic params. As you can see, we made a *ton* of assumptinos to get here, but this way favors convention over a bunch of manual configuration.\r\n\r\n### Controllers\r\n\r\nNext we setup our two controller:\r\n\r\n```d\r\n// /source/core/controllers/authors_controller.d\r\n\r\nmodule core.controllers.authors;\r\n\r\nimport action_dispatch.all;\r\n\r\nclass AuthorsController : ActionController {\r\n  mixin DynamicClassImplementation!();\r\n  \r\n  // GET /authors\r\n  @DynamicallyAvailable\r\n  void index() {\r\n    respondTo(\"html\", delegate void() {\r\n      response.render!(\"authors/index.dt\", request);\r\n    });\r\n  }\r\n\r\n  // GET /authors/new\r\n  @DynamicallyAvailable\r\n  void init() {\r\n    // render the right view\r\n  }\r\n\r\n  // POST /authors\r\n  @DynamicallyAvailable\r\n  void create() {\r\n    // render the right view\r\n  }\r\n\r\n  // GET /authors/:id\r\n  @DynamicallyAvailable\r\n  void show() {\r\n    // render the right view\r\n  }\r\n\r\n  // GET /authors/:id/edit\r\n  @DynamicallyAvailable\r\n  void edit() {\r\n    // render the right view\r\n  }\r\n\r\n  // PUT/PATCH /authors/:id\r\n  @DynamicallyAvailable\r\n  void update() {\r\n    // render the right view\r\n  }\r\n\r\n  // DELETE /authors/:id\r\n  @DynamicallyAvailable\r\n  void destroy() {\r\n    // render the right view\r\n  }\r\n}\r\n\r\n// /source/core/controllers/books_controller.d\r\n\r\nmodule core.controllers.books;\r\n\r\nimport action_dispatch.all;\r\n\r\nclass BooksController : ActionController {\r\n  mixin DynamicClassImplementation!();\r\n  \r\n  // GET /books\r\n  @DynamicallyAvailable\r\n  void index() {\r\n    respondTo(\"html\", delegate void() {\r\n      response.render!(\"books/index.dt\", request);\r\n    });\r\n  }\r\n\r\n  // GET /books/new\r\n  @DynamicallyAvailable\r\n  void init() {\r\n    // render the right view\r\n  }\r\n\r\n  // POST /books\r\n  @DynamicallyAvailable\r\n  void create() {\r\n    // render the right view\r\n  }\r\n\r\n  // GET /books/:id\r\n  @DynamicallyAvailable\r\n  void show() {\r\n    // render the right view\r\n  }\r\n\r\n  // GET /books/:id/edit\r\n  @DynamicallyAvailable\r\n  void edit() {\r\n    // render the right view\r\n  }\r\n\r\n  // PUT/PATCH /books/:id\r\n  @DynamicallyAvailable\r\n  void update() {\r\n    // render the right view\r\n  }\r\n\r\n  // DELETE /books/:id\r\n  @DynamicallyAvailable\r\n  void destroy() {\r\n    // render the right view\r\n  }\r\n}\r\n```\r\n\r\nThere's a lot going on up there, but it's pretty simple. Basically, for every resource, we have a controller. So for the `books` resource we have the `BooksController` and for the `authors` resource, we have the `AuthorsController`. When a request comes in to `ActionPack` and a match is found, we instantiate a new instance of the controller and call the appropriate method on it. So, if we request `/authors`, internally `ActionPack` is doing something like this:\r\n\r\n```d\r\ncontroller = new AuthorsController(request, response, params);\r\ncontroller.index();\r\n```\r\n\r\nPretty simple.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (git checkout -b my-new-feature)\r\n3. Commit your changes (git commit -am 'Added some feature')\r\n4. Push to the branch (git push origin my-new-feature)\r\n5. Create new Pull Request\r\n\r\n## License\r\n\r\nMIT.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}