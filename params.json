{"name":"D Lang Action Pack","tagline":"Rails-like routing for your Vibe.D project!","body":"D Lang Action Pack\r\n===========\r\n\r\nA router for use with [Vibe-D](http://vibed.org/) that mimics the way routers and controllers work in [Rails](http://rubyonrails.org/).\r\n\r\n## Installation\r\n\r\nAdd the following to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"action-pack\": \"~master\"\r\n}\r\n```\r\n\r\n## Usage\r\n\r\nHere's a very quick sample run through of how you can use the `ActionPack` routing.\r\n\r\n### `App.d` and the router\r\n\r\nFirst you have to setup your `app.d` file with your router and your list of routes:\r\n\r\n```d\r\n// app.d\r\n\r\nimport vibe.d;\r\nimport action_dispatch.all;\r\n\r\nshared static this()\r\n{\r\n\tauto router = new ActionRouter;\r\n\trouter.get(\"/\", \"BooksController\", \"index\");\r\n\t\r\n\trouter.resources(\"authors\", delegate void (ActionNamespace authors) {\r\n\t  authors.resources(\"books\");\r\n\t});\r\n\r\n\tauto settings = new HTTPServerSettings;\r\n\tsettings.port = 8080;\r\n\r\n\tlistenHTTP(settings, router);\r\n}\r\n```\r\n\r\nIn the above example we map the default route of `/` to be handled by the `BooksController` action `index`.\r\n\r\nThen we define a resource, `authors` and a sub resource for `authors`: `books`. This generates a routing table:\r\n\r\n\r\n|Method|Route|Controller|Action|\r\n|:------|:-----------|:-----|:----|\r\n|GET|/|BooksController|#ndex|\r\n|GET|/authors/:author_id/books|BooksController|#index|\r\n|GET|/authors/:author_id/books/new|BooksController|#init|\r\n|POST|/authors/:author_id/books|BooksController|#create|\r\n|GET|/authors/:author_id/books/:id|BooksController|#show|\r\n|GET|/authors/:author_id/books/:id/edit|BooksController|#edit|\r\n|PUT|/authors/:author_id/books/:id|BooksController|#update|\r\n|PATCH|/authors/:author_id/books/:id|BooksController|#update|\r\n|DELETE|/authors/:author_id/books/:id|BooksController|#destroy|\r\n|GET|/authors|AuthorsController|#index|\r\n|GET|/authors/new|AuthorsController|#init|\r\n|POST|/authors|AuthorsController|#create|\r\n|GET|/authors/:id|AuthorsController|#show|\r\n|GET|/authors/:id/edit|AuthorsController|#edit|\r\n|PUT|/authors/:id|AuthorsController|#update|\r\n|PATCH|/authors/:id|AuthorsController|#update|\r\n|DELETE|/authors/:id|AuthorsController|#destroy|\r\n\r\n\r\nFrom just a few lines of code we get 17 routes! All with automatic params. As you can see, we made a *ton* of assumptinos to get here, but this way favors convention over a bunch of manual configuration.\r\n\r\n### Controllers\r\n\r\nNext we setup our two controller:\r\n\r\n```d\r\n// /source/core/controllers/authors_controller.d\r\n\r\nmodule core.controllers.authors;\r\n\r\nimport action_dispatch.all;\r\n\r\nclass AuthorsController : ActionController {\r\n  mixin DynamicClassImplementation!();\r\n  \r\n  @DynamicallyAvailable {\r\n    // GET /authors\r\n    void index() {\r\n      respondTo(delegate void(Format format) {\r\n        format.html(delegate void() {\r\n          response.render!(\"books/index.dt\", request);\r\n        });\r\n\r\n        format.json(delegate void() { // render some JSON });\r\n      });\r\n    }\r\n\r\n    // GET /authors/new\r\n    void init() {\r\n      // render the right view\r\n    }\r\n\r\n    // POST /authors\r\n    void create() {\r\n      // render the right view\r\n    }\r\n\r\n    // GET /authors/:id\r\n    void show() {\r\n      // render the right view\r\n    }\r\n\r\n    // GET /authors/:id/edit\r\n    void edit() {\r\n      // render the right view\r\n    }\r\n\r\n    // PUT/PATCH /authors/:id\r\n    void update() {\r\n      // render the right view\r\n    }\r\n\r\n    // DELETE /authors/:id\r\n    void destroy() {\r\n      // render the right view\r\n    }\r\n  }\r\n}\r\n\r\n// /source/core/controllers/books_controller.d\r\n\r\nmodule core.controllers.books;\r\n\r\nimport action_dispatch.all;\r\n\r\nclass BooksController : ActionController {\r\n  mixin DynamicClassImplementation!();\r\n  \r\n  @DynamicallyAvailable {\r\n    // GET /authors/:authors_id/books\r\n    void index() {\r\n      respondTo(delegate void(Format format) {\r\n        format.html(delegate void() {\r\n          response.render!(\"books/index.dt\", request);\r\n        });\r\n\r\n        format.json(delegate void() { // render some JSON });\r\n      });\r\n    }\r\n\r\n    // GET /authors/:authors_id/books/new\r\n    void init() {\r\n      // render the right view\r\n    }\r\n\r\n    // POST /authors/:authors_id/books\r\n    void create() {\r\n      // render the right view\r\n    }\r\n\r\n    // GET /authors/:authors_id/books/:id\r\n    void show() {\r\n      // render the right view\r\n    }\r\n\r\n    // GET /authors/:authors_id/books/:id/edit\r\n    void edit() {\r\n      // render the right view\r\n    }\r\n\r\n    // PUT/PATCH /authors/:authors_id/books/:id\r\n    void update() {\r\n      // render the right view\r\n    }\r\n\r\n    // DELETE /authors/:authors_id/books/:id\r\n    void destroy() {\r\n      // render the right view\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThere's a lot going on up there, but it's pretty simple. Basically, for every resource, we have a controller. So for the `books` resource we have the `BooksController` and for the `authors` resource, we have the `AuthorsController`. When a request comes in to `ActionPack` and a match is found, we instantiate a new instance of the controller and call the appropriate method on it. So, if we request `/authors`, internally `ActionPack` is doing something like this:\r\n\r\n```d\r\ncontroller = new AuthorsController(request, response, params);\r\ncontroller.index();\r\n```\r\n\r\nPretty simple.\r\n\r\n# In depth\r\n\r\nI'll go over the concepts more in depth here.\r\n\r\n## Controllers\r\n\r\nControllers are objects that represent the group of logic around a single resource. They're the \"C\" in [MVC](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller). In `action-pack` they have play a central role of responding to requests. Every route is defined with a controller and an action. An action is a method on a controller with the signature:\r\n\r\n```d\r\nvoid()\r\n```\r\n\r\nwhich is pretty easy to implement. They don't return anything (because there isn't anything listening for a return value). They just manipulate the `response` object.\r\n\r\n### Actions\r\n\r\nActions can really perform any amount of work required to process a request. They have access to the `request` object and the `response` object as well as the `params`.\r\n\r\n### Params\r\n\r\nEvery action has access to a `@property` called `params`. This has the parsed params from the route with strings as keys. So with the route:\r\n\r\n```\r\n/authors/:author_id/books\r\n```\r\n\r\nAnd the URL\r\n\r\n```\r\n/authors/1/books\r\n```\r\n\r\nThe `params` hash will look like this:\r\n\r\n```\r\n{\r\n  \"params\": \"1\"\r\n}\r\n```\r\n\r\nNotice that the `1` is a `string` and not an `integer`.\r\n\r\n### respondTo\r\n\r\nTo make routing more restful, I've added an implementation of Rails `#respondTo` method for `ActionController`. There are two version of the `#respondTo` method.\r\n\r\nThe first one is:\r\n\r\n```d\r\nvoid respondTo(string format, void delegate() yield)\r\n```\r\n\r\nThis one takes a `string` as the first argument and a `delegate` method. The string has to be a literal match to the current `format` specified by the controller (based on the extension of the request, for example, `.html`). The delegate is only called if there is a match, otherwise nothing is done.\r\n\r\nThe second is:\r\n\r\n```d\r\nvoid respondTo(void delegate(Format) yield)\r\n```\r\n\r\nThis one only takes the `delegate`, but this `delegate` must accept a single argument, which is a `Format` object. The `Format` object is very simple and provides some shortcut methods. This way you can do things like\r\n\r\n```d\r\nformat.html(delegate void(Format format) { // do stuff here if this an html request });\r\n```\r\n\r\nThis way, in a single `respondTo` `delegate` method you can address multiple formats.\r\n\r\n## Routing\r\n\r\nThe goal of this is to make routing as dead simple as possible, and to avoid writing a bunch of redundant code. The `vibe.d` example on routing looks like this:\r\n\r\n```d\r\nshared static this()\r\n{\r\n  auto router = new URLRouter;\r\n  router.get(\"/\", &index);\r\n}\r\n\r\nvoid index(HTTPServerRequest req, HTTPServerResponse res)\r\n{\r\n\tres.render!(\"index.dt\", req);\r\n}\r\n```\r\n\r\nFor a restful API this would require writing code by hand that looks very similar over and over again:\r\n\r\n```d\r\nshared static this()\r\n{\r\n  auto router = new URLRouter;\r\n  router.get(\"/books\");\r\n  router.get(\"/books/:id\");\r\n  router.get(\"/books/new\");\r\n\r\n  // etc etc\r\n}\r\n```\r\n\r\nAnd that only gets us through a single resource. Because I come from a Rails background I figured there has to be a way to clean this up.\r\n\r\n### Reources\r\n\r\nResources are at the heart of routing in `action-pack`. A resource is defined with just a name, and using that as a default URL root and default controller. Every resource automatically defines several routes. The simples way to define a resource:\r\n\r\n```d\r\nauto router = new ActionRouter;\r\nrouter.resources(\"books\");\r\n```\r\n\r\nBecause the convention for a resource is well defined, this one line can extrapolate all the routes we intend for this resource and hook them up to the appropriate controller and actions.\r\n\r\n#### Nesting\r\n\r\nBecause resources frequently belong to one another, they can be nested:\r\n\r\n```d\r\nauto router = new ActionRouter;\r\nrouter.resources(\"authors\", delegate void (ActionNamespace authors) {\r\n  authors.resources(\"books\");\r\n});\r\n```\r\n\r\nThis will generate the `books` routes with a prefix automatically of `authors/:author_id`.\r\n\r\n### Custom Routes\r\n\r\nInternally when you call `#resources` on `ActionRouter`, it just calls a group of helper methods. All of these methods are publicly accessible, so you can use them to create custom routes.\r\n\r\nIf you want to have a `GET` request for `/about` (and not an entire resource), you can route it manually:\r\n\r\n```d\r\nrouter.get(\"/about\", \"MainController\", \"about\");\r\n```\r\n\r\nThe first param is the path, the second is the name (as a string) of the controller and the last is the action to call.\r\n\r\n### Assets\r\n\r\nAssets aren't supported right now, but there's a sort of solution:\r\n\r\n```d\r\nrouter.assets(\"*\");\r\n```\r\n\r\nThis sets up a globally accepted route, so it should always be defined last. It takes any route and looks in the `./public` folder for a match. Like I said, not that great, but it works.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (git checkout -b my-new-feature)\r\n3. Commit your changes (git commit -am 'Added some feature')\r\n4. Push to the branch (git push origin my-new-feature)\r\n5. Create new Pull Request\r\n\r\n## License\r\n\r\nMIT.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}